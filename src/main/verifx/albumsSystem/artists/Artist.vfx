import antidote.crdts.registers.LWWRegister
import antidote.crdts.LamportClock
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof

/////////////////////////////////////////
//
// CREATE UPDATE-WINS TABLE Artists (
//    name VARCHAR PRIMARY KEY,
//    country LWW VARCHAR
// )
/////////////////////////////////////////

class Artist(name: String, country: LWWRegister[String]) extends CvRDT[Artist] {

  def updateCountry(newCountry: String, stampCountry: LamportClock) =
    new Artist(this.name, this.country.assign(newCountry, stampCountry))

  def merge(that: Artist) =
    new Artist(this.name, this.country.merge(that.country))

  def compare(that: Artist) =
    this.country.compare(that.country)

//  override def equals(that: Artist) =
  //  this.name == that.name && this.country.equals(that.country)

  //Uma vez que o compatible está defido para qualquer CvRDT então posso chamar o compatible para todos os objetos
  override def compatible(that: Artist) =
    this.name == that.name && this.country.compatible(that.country)

}

//Provas do Kevin permitem verificar a convergência
//Tenho de definir provas para verificar que cada uma das operações do objeto funciona corretamente
object Artist extends CvRDTProof[Artist] {

  proof Artist_updateCountry_works {
    forall(a: Artist, country1: String, country2: String, c1: LamportClock, c2: LamportClock) {

      ( a.reachable() && c1.smaller(c2) ) =>: {

          val a1 = a.updateCountry(country1, c1)
          val a2 = a.updateCountry(country2, c2)
          val a12 = a1.merge(a2)

          a1.name == a.name && a2.name == a.name &&
          a1.country.value == country1 && a2.country.value == country2 &&
          a12.name == a.name && a12.country.value == country2
      }
    }
  }

}