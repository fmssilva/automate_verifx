import antidote.crdts.lemmas.CvRDT

/*
 * Defines a correctness proof for state-based CRDTs (CvRDT).
 *
 * A data type `T` is a CvRDT, iff it guarantees convergence.
 * And it guarantees convergence iff:
 *      - MERGE function is idempotent, commutative and associative.
 *      - The `compatible` predicate commutes.
 *      - The `equals` method is correct.
 *
 * This generic type of CvRDTs 'T', must fields with specific data types.
 * If 'T' receives 1 generic type parameter (ex Album[Time]), then use the CvRDTProof1 trait.
 * If 'T' receives 2 generic type parameters (ex Album[Time, Artist]), then use the CvRDTProof2 trait.
 * ...and so on for more generic type parameters.
 */

trait CvRDTProof[T <: CvRDT[T]] {

    /*
     * MERGE
     *
     * merge functions converges iff it guarantees:
     *   - idempotent
     *        ∀x : reachable(x)
     *          =>  merge(x, x) == x
     *    - commutative
     *        ∀x,y : reachable(x) /\ reachable(y) /\ compatible(x,y)
     *          =>  merge(x, y) == merge(y, x) /\
     *              reachable(merge(x, y)
     *    - associative
     *        ∀x,y,z : reachable(x) /\ reachable(y) /\ reachable(z) /\
     *                 compatible(x,y) /\ compatible(x, z) /\ compatible(y, z)
     *          =>  merge(merge(x, y), z) == merge(x, merge(y, z)) /\
     *              reachable(merge(merge(x, y), z))
     *
     * The `reachable` and `compatible` predicates are data type dependent:
     *
     * - REACHABLE - checks the validity of the state
     *          i.e. it should be reachable starting from the initial state and applying only supported operations.
     *
     * - COMPATIBLE - checks that two states are compatible.
     *          For example, a LWWRegister keeps a value and a timestamp.
     *          Since timestamps are unique, we know that two registers that have the same timestamp must have the same value.
     *                  (this.stamp == that.stamp) =>: (this.value == that.value)
     *          Hence, if two registers have the same timestamp but different values they are not compatible since this cannot occur in practice.
     */
    proof mergeCorrect {
        forall(x: T, y: T, z: T) {
            ( x.reachable() && y.reachable() && z.reachable() &&
              x.compatible(y) && x.compatible(z) && y.compatible(z)
            ) =>: {
                x.merge(x).equals(x) && // idempotent
                x.merge(y).equals(y.merge(x)) && // commutative
                x.merge(y).merge(z).equals(x.merge(y.merge(z))) && // associative
                x.merge(y).reachable() && // merged state is reachable
                x.merge(y).merge(z).reachable() &&
                x.compatible(y) == y.compatible(x) // compatible commutes
            }
        }
    }

    /*
     * COMPATIBLE
     *
     * compatible predicate must commute
     * i.e. the outcome should not depend on the order of the arguments.
     */
    proof compatibleCommutes {
        forall (x: T, y: T) {
            ( x.reachable() && y.reachable()
            ) =>: ( x.compatible(y) == y.compatible(x) )
        }
    }

    /*
     * TODO... pra que é isto??? e pq não ser um equals normal... ??
     */
    proof compareCorrect {
        forall (x: T, y: T) {
            ( x.reachable() && y.reachable() && x.compatible(y)
            ) =>: ( x.equals(y) == (x == y) )
        }
    }


    //////////////////////////////////////////////////////////////
    // If the "is_a_CvRDT" proof is too big, and aborts without a result
    // so we can divide that proof in parts and run each part at a time
    //////////////////////////////////////////////////////////////

    proof mergeCommutative {
        forall (x: T, y: T) {
            (x.reachable() && y.reachable() && x.compatible(y)
            ) =>: {
                x.merge(y).equals(y.merge(x)) &&
                x.merge(y).reachable()
            }
        }
    }

    proof mergeIdempotent {
        forall (x: T) {
            x.reachable() =>: x.merge(x).equals(x)
        }
    }

    proof mergeAssociative {
        forall (x: T, y: T, z: T) {
            ( x.reachable() && y.reachable() && z.reachable() &&
                x.compatible(y) && x.compatible(z) && y.compatible(z)
            ) =>: {
                x.merge(y).merge(z).equals(x.merge(y.merge(z))) &&
                x.merge(y).merge(z).reachable()
            }
        }
    }


}