import antidote.crdts.lemmas.CvRDT

/*
 * Extend this trait to prove convergence for a polymorphic state-based CRDT that takes 1 type parameter.
 * The type parameter `T` is a type constructor of a state-based CRDT,
 * e.g. class LWWRegister[V](...) extends CvRDT[LWWRegister[V]]
 *      object LWWRegister extends CvRDTProof1[LWWRegister]
 *      This will generate a polymorphic proof that proves that `LWWRegister` is a CvRDT,
 *      independent of the type of the value the `LWWRegister` stores (i.e. proves it forall `V`).
 */
trait CvRDTProof1[ T[A] <: CvRDT[T[A]] ] {

    // Proof that the data type `T` is a CvRDT
    proof is_a_CvRDT[S] {
        forall (x: T[S], y: T[S], z: T[S]) {
            ( x.reachable() && y.reachable() && z.reachable() &&
              x.compatible(y) && x.compatible(z) && y.compatible(z)
            ) =>: {
                x.merge(x).equals(x) && // idempotent
                x.merge(y).equals(y.merge(x)) && // commutative
                x.merge(y).merge(z).equals(x.merge(y.merge(z))) && // associative
                x.merge(y).reachable() && // merged state is reachable
                x.merge(y).merge(z).reachable() &&
                x.compatible(y) == y.compatible(x) // compatible commutes
            }
        }
    }


  proof compatibleCommutes[S] {
    forall (x: T[S], y: T[S]) {
      ( x.reachable() && y.reachable()
      ) =>: ( x.compatible(y) == y.compatible(x) )
    }
  }

  // TODO: mudar o nome deste para ser equalsCorrect
  // e assim verificar tudo para o caso de não ser BD sempre crescente??
  // O equals estar implementado dessa forma tem a ver com a definição formal de um state-based CRDT
  // No nosso caso podes fazer o que estás a dizer
  proof compareCorrect[S] {
    forall (x: T[S], y: T[S]) {
      ( x.reachable() && y.reachable() && x.compatible(y)
      ) =>: ( x.equals(y) == (x == y) )
    }
  }


  proof mergeIdempotent[S] {
    forall (x: T[S]) {
      x.reachable() =>: x.merge(x).equals(x)
    }
  }



  proof mergeCommutative[S] {
    forall (x: T[S], y: T[S]) {
      (x.reachable() && y.reachable() && x.compatible(y)
      ) =>: {
        x.merge(y).equals(y.merge(x))
        x.merge(y).reachable()
      }
    }
  }



  proof mergeAssociative[S] {
    forall (x: T[S], y: T[S], z: T[S]) {
      ( x.reachable() && y.reachable() && z.reachable() &&
        x.compatible(y) && x.compatible(z) && y.compatible(z)
      ) =>: {
        x.merge(y).merge(z).equals(x.merge(y.merge(z)))
        // These next verifications are done in mergeAssociative2 and 3
        // x.merge(y).merge(z).reachable()
        // x.merge(y).compatible(z)
        // x.compatible(y.merge(z))
      }
    }
  }


  proof mergeReachable[S] {
    forall (x: T[S], y: T[S], z: T[S]) {
      ( x.reachable() && y.reachable() && z.reachable() &&
        x.compatible(y) && x.compatible(z) && y.compatible(z)
       ) =>: {
        x.merge(y).merge(z).reachable()
      }
    }
  }


  proof mergeCompatible[S] {
    forall (x: T[S], y: T[S], z: T[S]) {
      ( x.reachable() && y.reachable() && z.reachable() &&
        x.compatible(y) && x.compatible(z) && y.compatible(z)
       ) =>: {
        x.merge(y).compatible(z)
        x.compatible(y.merge(z))
      }
    }
  }



}