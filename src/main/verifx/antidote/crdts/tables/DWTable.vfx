import antidote.crdts.lemmas.CvRDT
import antidote.crdts.tables.DWFlags

trait DWTable[  PK  , V <: CvRDT[V], Time, T <: DWTable[PK, V, Time, T]] extends CvRDT {

    val elements: Map[PK, Tuple[DWFlags, V]]

    val before: (Time, Time) => Boolean

    // FORCE TABLES TO HAVE A COPY FUNCTION
    def copy(newElements: Map[PK, Tuple[DWFlags, V]]) : T


    // HELPER FUNCTIONS FOR FK SYSTEM
    def getVersion (pk: PK): Int = {
        val elem = this.elements.get(pk)
        if (elem.fst.flag == 0) // DELETED
            0
        else
            elem.fst.version
    }


    // DWTable Functions

    override def reachable(): Boolean = {
        this.elements.values().forall(
            (elem: Tuple[DWFlags, V]) =>
                elem.fst.version >= 1 &&
                elem.fst.flag != 0 &&  // NOT DELETED
                elem.snd.reachable()
        )
    }

    def merge (that: T) = {
        val mergedElements = this.elements.combine(
            that.elements,
            (elem1: Tuple[DWFlags, V], elem2: Tuple[DWFlags, V]) => {
                val e1_flags = elem1.fst
                val e2_flags = elem2.fst
                if (e1_flags.version > e2_flags.version)
                    elem1
                else if (e2_flags.version > e1_flags.version)
                    elem2
                else if (e1_flags.flag == 0 && e2_flags.flag == 1) // this is DELETED
                    elem1
                else if (e2_flags.flag == 0 && e1_flags.flag == 1) // that is DELETED
                    elem2
                else
                    new Tuple(e1_flags, elem1.snd.merge(elem2.snd)) // flags are the same so use e1; and merge Values from e1 and e2
            })
        this.copy(mergedElements)
    }

    override def compatible(that: T): Boolean = {
        this.before == that.before &&
        this.elements.zip(that.elements).values().forall(
            (elem: Tuple[Tuple[DWFlags, V], Tuple[DWFlags, V]]) => {
//                val e1 = elem.fst
//                val e2 = elem.snd
//                e1.fst.compatible(e2.fst) //&& // DWFlags
//                e1.snd.compatible(e2.snd)   // Value
                true
            }
        )
    }

    //ignore this compare and override equals directly in an efficient way
    def compare(that: T): Boolean = {
        false
//        this.elements.zip(that.elements).values().forall(
//                (elem: Tuple[Tuple[DWFlags, V], Tuple[DWFlags, V]]) => {
//                    val e1 = elem.fst
//                    val e2 = elem.snd
//                    e1.fst.compare(e2.fst) && // flags
//                    e1.snd.compare(e2.snd)    // V
//                }
//            )
    }

    override def equals(that: T): Boolean = {
        this.before == that.before &&
        this.elements.zip(that.elements).values().forall(
            (elem: Tuple[Tuple[DWFlags, V], Tuple[DWFlags, V]]) => {
                val e1 = elem.fst
                val e2 = elem.snd
                e1.fst.equals(e2.fst) && // flags
                e1.snd.equals(e2.snd)    // Value
            }
        )
    }



}


