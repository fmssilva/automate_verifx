import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof


// DELETE = 0; VISIBLE = 1
class DWFlags(version: Int, flag: Int, fk_versions: Vector[Int]) extends CvRDT[DWFlags] {

    ///////////////////////////////////////////////////////////////
    //            DWFlags CvRDT methods
    ///////////////////////////////////////////////////////////////

    /*
     * REACHABLE
     * return true if all versions and flags are valid values
     */
	override def reachable(): Boolean = {
		this.version >= 1 &&
		(this.flag == 0 || this.flag == 1) &&
		this.fk_versions.forall(
		    (fk_version: Int) => (fk_version >= 1)
		)
	}

    /*
	 * EQUALS
	 * return true if all versions and flags of this DWFlag equals that DWFlag
	 * » if we do not override this method, the default implementation in CvRDT will be used
     *      which will compare if (this <= that and that <= this), which is unnecessary work
     */
    override def equals (that: DWFlags): Boolean =
        this.version == that.version &&
        this.flag == that.flag &&
        this.fk_versions == that.fk_versions

    /*
     * COMPARE
     TODO -------- mas o compare só interessa para clocks pra ver se é concurrentes... ou não???
     * return true if this DWFlag <= that DWFlag
     * » this method is never used, if we override the equal method of the CvRDT
     */
    def compare(that: DWFlags): Boolean =
        false
//        this.version <= that.version &&
//        this.flag <= that.flag
        //TODO: meter tb o fk_versions


    /*
     * COMPATIBLE
     * return true if all fields are compatible, i.e. 'this' and 'that' can be merged
     *       we know that both 'this' and 'that' are of the DWFlags type,
     *       so they both have the same number and types of fields.
     *       The only thing we could check is if the fk_versions vectors have the same length
     *       but we don't need to check that, because we know that they are created with same size
     */
     override def compatible(that: DWFlags): Boolean =
            true


    /*
     * MERGE
     * return a new DWFlag with correct merged fields
     *      (this merge is done according with Delete-Wins Semantics)
     */
	def merge(that: DWFlags): DWFlags = {
	    // if different versions -> we choose the bigger one
        if (this.version > that.version)
            this
        else if (that.version > this.version)
            that
        else {
            // if both flags are the same, we merge the fk_versions vector (if both are DELETED we don't even need to merge, but we do it to achieve merge commutative)
            if (this.flag == that.flag) {
                val fk_versions = this.fk_versions.zip(that.fk_versions).map(
                                    (elem: Tuple[Int, Int]) => {
                                        if (elem.fst > elem.snd)
                                            elem.fst
                                        else
                                            elem.snd
                                    }
                                )
                new DWFlags(this.version, this.flag, fk_versions)
            }
            // else the flags are different, and so we keep the DELETED one
            else if (this.flag == 0)
                this
            else // that.flag == 0
                that
        }
	}




    ///////////////////////////////////////////////////////////////
    //     DWFlags helper methods to be called by FK_Systems
    ///////////////////////////////////////////////////////////////

    /*
     * GET VERSION
     * return the version of the FK with the given index
     * @Pre: the index is valid: 0 <= idx < fk_versions.size
     */
    def get_fk_version(idx: Int): Int =
        this.fk_versions.get(idx)


    /*
     * SET FLAG
     * return a new DWFlag with the flag set to new_flag
     */
    def setFlag(new_flag: Int): DWFlags = {
        new DWFlags(this.version, new_flag, this.fk_versions)
    }

    /*
     * SET INSERTION
     * return a new DWFlag with the version incremented by 1 and the flag INSERTED
     */
    def set_insertion(): DWFlags = {
        new DWFlags(this.version + 1, 1, this.fk_versions)
    }

}


object DWFlags extends CvRDTProof[DWFlags] { }
