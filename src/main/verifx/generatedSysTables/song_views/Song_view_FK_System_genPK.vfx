
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.LamportClock
import antidote.crdts.VersionVector
import antidote.crdts.lemmas.CvRDTProof6
import generatedSysTables.song_views.Song_viewsTable_genPK
import generatedSysTables.arts.ArtsTable_genPK
import generatedSysTables.songs.SongsTable_genPK
import generatedSysTables.albs.AlbsTable_genPK
import generatedSysTables.genres.GenresTable_genPK
import generatedSysTables.arts.Art

/*
 * class implementing the Convergence proof
 */
class Song_view_FK_System_genPK[Time, PK, A, B, C, D](
					song_viewsTable: Song_viewsTable_genPK[Time, PK],
					artsTable: ArtsTable_genPK[Time, A], 
					songsTable: SongsTable_genPK[Time, B], 
					albsTable: AlbsTable_genPK[Time, C], 
					genresTable: GenresTable_genPK[Time, D] )
					extends CvRDT[Song_view_FK_System_genPK[Time, PK, A, B, C, D]] {


  /*
   * OVERRIDE DEFAULT IMPLEMENTATION OF METHODS IN CvRDT TRAIT
   */ 

	//REACHABLE - check if this table and the referenced tables are reachable
	override def reachable(): Boolean =
				this.song_viewsTable.reachable() && 
				this.artsTable.reachable() && 
				this.songsTable.reachable() && 
				this.albsTable.reachable() && 
				this.genresTable.reachable()


	//COMPATIBLE - check if this Song_view_FK_System is compatible with that song_viewsTable
	override def compatible(that: Song_view_FK_System_genPK[Time, PK, A, B, C, D]): Boolean =
				this.song_viewsTable.compatible(that.song_viewsTable) &&
				this.artsTable.compatible(that.artsTable) &&
				this.songsTable.compatible(that.songsTable) &&
				this.albsTable.compatible(that.albsTable) &&
				this.genresTable.compatible(that.genresTable)


	//EQUALS - check if this Song_view_FK_System is equal to that Song_view_FK_System
	override def equals(that: Song_view_FK_System_genPK[Time, PK, A, B, C, D]) =
				this == that


  /*
   * IMPLEMENT DECLARED METHODS IN CvRDT TRAIT
   */

	//MERGE this Song_view_FK_System with that Song_view_FK_System
	def merge(that: Song_view_FK_System_genPK[Time, PK, A, B, C, D]) =
		new Song_view_FK_System_genPK(
				this.song_viewsTable.merge(that.song_viewsTable), 
				this.artsTable.merge(that.artsTable),
				this.songsTable.merge(that.songsTable),
				this.albsTable.merge(that.albsTable),
				this.genresTable.merge(that.genresTable) )

	//COMPARE this Song_view_FK_System with that Song_view_FK_System
	//ignore
	def compare(that: Song_view_FK_System_genPK[Time, PK, A, B, C, D]) = 
				true



  /*
   * EXTRA METHODS FOR PROOFS
   */

	// REACHABLE WITH ASSUMPTIONS - ASSOCIATIVITY
	def reachableWithAssociativityAssumptions(): Boolean = {
				this.song_viewsTable.reachable() && 
				this.artsTable.reachable() &&
				this.songsTable.reachable() &&
				this.albsTable.reachable() &&
				this.genresTable.reachable() && 
				this.mergeValuesAssumptions()
	}
		//HELPER METHOD - ASSUMPTIONS FOR MERGE ASSOCIATIVITY - for the tables of this Song_view_FK_System
		private def mergeValuesAssumptions(): Boolean = {
			forall(v1: Song_viewsTable_genPK[Time, PK], v2: Song_viewsTable_genPK[Time, PK], v3: Song_viewsTable_genPK[Time, PK])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  } &&
			forall(v1: ArtsTable_genPK[Time, A], v2: ArtsTable_genPK[Time, A], v3: ArtsTable_genPK[Time, A])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  } &&
			forall(v1: SongsTable_genPK[Time, B], v2: SongsTable_genPK[Time, B], v3: SongsTable_genPK[Time, B])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  } &&
			forall(v1: AlbsTable_genPK[Time, C], v2: AlbsTable_genPK[Time, C], v3: AlbsTable_genPK[Time, C])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  } &&
			forall(v1: GenresTable_genPK[Time, D], v2: GenresTable_genPK[Time, D], v3: GenresTable_genPK[Time, D])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  }
		}

}



/*
 * OBJECT FOR EXTRA PROOFS
 */
object Song_view_FK_System_genPK extends CvRDTProof6[Song_view_FK_System_genPK] {

	//MERGE ASSOCIATIVE
	proof mergeIsAssociative_genPK[Time, PK] {
		forall(s1: Song_viewsTable_genPK[Time, PK], s2: Song_viewsTable_genPK[Time, PK], s3: Song_viewsTable_genPK[Time, PK]) {
			(s1.reachable() && s2.reachable() && s3.reachable() &&
			  s1.compatible(s2) && s1.compatible(s3) && s2.compatible(s3)
			) =>: {
				val aux = s1.merge(s2).merge(s3)
				aux.equals(s1.merge( s2.merge(s3) ))
				aux.reachable()
				}
		}
	}

}
