
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.LamportClock
import antidote.crdts.VersionVector
import antidote.crdts.lemmas.CvRDTProof1
import generatedSysTables.albs.AlbsTable
import generatedSysTables.arts.ArtsTable
import generatedSysTables.arts.Art

/*
 * class implementing the FK - Referential Integrity - Invariant
 */
class Alb_FK_System[Time](
					albsTable: AlbsTable[Time],
					artsTable: ArtsTable[Time] )
					extends CvRDT[Alb_FK_System[Time]]  {

    ///////////////////////////////////////////////////////////////
    //            FK_SYSTEM CvRDT methods
    ///////////////////////////////////////////////////////////////

	/*
    * REACHABLE
    * return true if the all tables of this system are reachable
    */
	override def reachable(): Boolean = {
        this.albsTable.reachable() &&
        this.artsTable.reachable() &&
        this.albsTable.elements.values().forall(
            (elem: Tuple[DWFlags, Alb]) => this.hasCorrectVersion(elem) )
    }

    /*
	 * EQUALS
	 * return true if all tables of this system are equal to all tables of that system
	 * » if we do not override this method, the default implementation in CvRDT will be used
     *      which will compare if (this <= that and that <= this), which is unnecessary work
     */
	override def equals(that: Alb_FK_System[Time]) =
        this.albsTable.equals(that.albsTable) &&
        this.artsTable.equals(that.artsTable)

    /*
     * COMPARE
     * return true if all tables of this system are <= than the tables of that system
     * » this method is never used, if we override the equal method of the CvRDT
     */
    def compare(that: Alb_FK_System[Time]) =
        this.albsTable.compare(that.albsTable) &&
        this.artsTable.compare(that.artsTable)

    /*
     * COMPATIBLE
     * return true if all tables of this system are compatible with the tables of that system
     */
	override def compatible(that: Alb_FK_System[Time]): Boolean =
				this.albsTable.compatible(that.albsTable) &&
				this.artsTable.compatible(that.artsTable)

    /*
     * MERGE
     * return a new system with the elements of each table of this system merged with tables of that system
     */
    def merge(that: Alb_FK_System[Time]) =
        new Alb_FK_System(  this.albsTable.merge(that.albsTable),
                            this.artsTable.merge(that.artsTable)
                          )


    ///////////////////////////////////////////////////////////////
    //  FK_SYSTEM helper methods to be called by other FK_Systems
    ///////////////////////////////////////////////////////////////

    /*
     * GET VERSION
     * return the version of the album with the given PK
     * @Pre: the album with the given PK exists
     * TODO: implementar isto dp pra testar sistemas com varios niveis de FK_Systems
      */
//    def getVersion (pk: AlbPK): Int = {
//        val alb = albsTable.elements.get(pk)
//        if (alb.fst.flag == 0) //DELETED
//            return 0
//        val art_version = artsTable.getVersion(albsTable.elements.get(pk).snd.artFK)
//        if (alb_version == art_version)
//            alb.fst.version
//        else
//             //amortizar caminho
//            0
//       }



    ///////////////////////////////////////////////////////////////
    //                 FK_SYSTEM Helper Methods
    ///////////////////////////////////////////////////////////////

    /*
     * HAS CORRECT VERSION
     * return true if the versions of the FKs in the given album are the same as the current versions of those FKs in the original referenced tables
     * @Pre: the album with the given PK exists
     */
    private def hasCorrectVersion(elem: Tuple[DWFlags, Alb]): Boolean = {
        val art_version = this.artsTable.getVersion(elem.snd.artFK)
        if (elem.fst.get_fk_version(0) == art_version) // each idx in fk_versions has the version of the referenced element corresponding to the FK_System referenced tables, IN ORDER
            true
        else {
            // To avoid future searches in all depth of the fks tree, we can amortize the path by marking this element as DELETED
            this.albsTable.setFlag(elem.snd.albPK, 0) //DELETED
            false
        }
    }

    /*
     * REF INTEGRITY HOLDS - ELEMENT
     * return true if the referential integrity holds for the album with the given PK
     */
    def refIntegrityHolds_elem(pk : AlbPK): Boolean =
        this.hasCorrectVersion(this.albsTable.elements.get(pk))

    /*
    * REF INTEGRITY HOLDS - TABLE
    * return true if the referential integrity holds for all elements in the table
    */
    def refIntegrityHolds_table(): Boolean =
        this.albsTable.elements.values().forall(
            (elem: Tuple[DWFlags, Alb]) => this.hasCorrectVersion(elem) )


    /*
     * DELETE REFERENCED ELEMENT
     * delete a random element from the referenced tables
     */
    def deleteReferencedElement(): Boolean = {
        //TODO: como ir buscar elementos random a um mapa?? ex:
        //val artPK = this.artsTable.keys().head
        val artPK = new ArtPK("0", "0")
        this.artsTable.delete(artPK)
    }

    def deleteAndInsertReferencedElement(): Boolean = {
        //TODO: ir buscar elem random
        val artPK = new ArtPK("0", "0")
        this.artsTable.delete(artPK)
        this.artsTable.insert(artPK)
    }

}



/*
 * OBJECT FOR REFERENTIAL INTEGRITY PROOFS
 */
object Alb_FK_System extends CvRDTProof1[Alb_FK_System] {

	// prova semelhante ao UW system
	// TODO: mas qual a lógica disto??
	//        estamos a usar o merge de 2 FK_Systems para representar as operações de delete() e on delete cascade por exemplo???
	proof genericReferentialIntegrity[Time] {
        forall(s1: Alb_FK_System[Time], s2: Alb_FK_System[Time], pk: AlbPK) {
            ( s1.compatible(s2) &&
              s1.reachable() && s2.reachable() &&
              s1.refIntegrityHolds_elem(pk) && s2.refIntegrityHolds_elem(pk)
              ) =>: {
                s1.merge(s2).refIntegrityHolds_elem(pk)
              }
        }
    }

    //TODO: não devia ser uma prova das FKs em que testa mesmo a apagar e a criar elementos?
    //  ex, se um sistema era reachable, e apagamos um elemento que era FK, então sistema deixa de ser
    proof refIntegrityHolds_For_Deletions[Time] {
        forall(s: Alb_FK_System[Time]) {
            ( s.reachable() &&
              s.deleteReferencedElement()
            ) =>: {
                s.refIntegrityHolds_table()
            }
        }
    }

    proof refIntegrityHolds_For_Deletions_And_Inserts[Time] {
        forall(s: Alb_FK_System[Time]) {
            ( s.reachable() &&
              s.deleteAndInsertReferencedElement()
            ) =>: {
                s.refIntegrityHolds_table()
            }
        }
    }

}
