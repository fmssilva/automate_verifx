
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.LamportClock
import antidote.crdts.VersionVector
import antidote.crdts.lemmas.CvRDTProof1
import generatedSysTables.albs.AlbsTable
import generatedSysTables.arts.ArtsTable
import generatedSysTables.arts.Art

/*
 * class implementing the FK - Referential Integrity - Invariant
 */
class Alb_FK_System[Time](
					albsTable: AlbsTable[Time],
					artsTable: ArtsTable[Time] )
					extends CvRDT[Alb_FK_System[Time]]  {


	//REACHABLE - check if this table and the referenced tables are reachable
	override def reachable(): Boolean =
        this.albsTable.reachable() &&
        this.artsTable.reachable()


    //TODO: getVersion do Alb_FK_System (só está feito o do ArtsTable)


    //MERGE this Alb_FK_System with that Alb_FK_System
    def merge(that: Alb_FK_System[Time]) =
        new Alb_FK_System(
                this.albsTable.merge(that.albsTable),
                this.artsTable.merge(that.artsTable) )




	//COMPATIBLE - check if this Alb_FK_System is compatible with that albsTable
	override def compatible(that: Alb_FK_System[Time]): Boolean =
				this.albsTable.compatible(that.albsTable) &&
				this.artsTable.compatible(that.artsTable)


	//COMPARE this Alb_FK_System with that Alb_FK_System
	def compare(that: Alb_FK_System[Time]) =
        this.albsTable.compare(that.albsTable) &&
        this.artsTable.compare(that.artsTable)



	//EQUALS - check if this Alb_FK_System is equal to that Alb_FK_System
	override def equals(that: Alb_FK_System[Time]) =
        this.albsTable.equals(that.albsTable) &&
        this.artsTable.equals(that.artsTable)



    def refIntegrityHolds(pk : AlbPK): Boolean = {
        //@Pre: this FK_System is reachable()
        this.albsTable.elements.values().forall(
            (elem: Tuple[DWFlags, Alb]) => {
                val art_version = this.artsTable.getVersion(elem.snd.artFK)
                if (elem.fst.version == art_version)
                    true
                else
                    false
                    //TODO: amortizar caminho ajudará??
            }
        )

    }


}



/*
 * OBJECT FOR EXTRA PROOFS
 */
object Alb_FK_System extends CvRDTProof1[Alb_FK_System] {

	//REFERENTIAL INTEGRITY
	proof genericReferentialIntegrity[Time] {
        forall(s1: Alb_FK_System[Time], s2: Alb_FK_System[Time], pk: AlbPK) {
            ( s1.compatible(s2) &&
              s1.reachable() && s2.reachable() &&
              s1.refIntegrityHolds(pk) && s2.refIntegrityHolds(pk)
              ) =>: {
                s1.merge(s2).refIntegrityHolds(pk)
              }
        }
    }


}
