
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.LamportClock
import antidote.crdts.VersionVector
import antidote.crdts.lemmas.CvRDTProof1
import generatedSysTables.albs.AlbsTable
import generatedSysTables.arts.ArtsTable
import generatedSysTables.arts.Art

/*
 * class implementing the FK - Referential Integrity - Invariant
 */
class Alb_FK_System[Time](
					albsTable: AlbsTable[Time],
					artsTable: ArtsTable[Time] )
					extends CvRDT[Alb_FK_System[Time]]  {

    ///////////////////////////////////////////////////////////////
    //            FK_SYSTEM CvRDT methods
    ///////////////////////////////////////////////////////////////

	/*
    * REACHABLE
    * return true if the all tables of this system are reachable
    */
	override def reachable(): Boolean = {
        this.albsTable.reachable() &&
        this.artsTable.reachable() &&
        this.albsTable.elements.values().forall(
            (elem: Tuple[DWFlags, Alb]) => this.hasVisibleFKsVersions(elem) )
    }

    /*
	 * EQUALS
	 * return true if all tables of this system are equal to all tables of that system
	 * » if we do not override this method, the default implementation in CvRDT will be used
     *      which will compare if (this <= that and that <= this), which is unnecessary work
     */
	override def equals(that: Alb_FK_System[Time]) =
        this.albsTable.equals(that.albsTable) &&
        this.artsTable.equals(that.artsTable)

    /*
     * COMPARE
     * return true if all tables of this system are <= than the tables of that system
     * » this method is never used, if we override the equal method of the CvRDT
     */
    def compare(that: Alb_FK_System[Time]) =
        this.albsTable.compare(that.albsTable) &&
        this.artsTable.compare(that.artsTable)

    /*
     * COMPATIBLE
     * return true if all tables of this system are compatible with the tables of that system
     */
	override def compatible(that: Alb_FK_System[Time]): Boolean =
				this.albsTable.compatible(that.albsTable) &&
				this.artsTable.compatible(that.artsTable)

    /*
     * MERGE
     * return a new system with the elements of each table of this system merged with tables of that system
     */
    def merge(that: Alb_FK_System[Time]) =
        new Alb_FK_System(  this.albsTable.merge(that.albsTable),
                            this.artsTable.merge(that.artsTable)
                          )


    ///////////////////////////////////////////////////////////////
    //                 FK_SYSTEM Helper Methods
    ///////////////////////////////////////////////////////////////


    /*
     * AMORTIZE PATH
     * To avoid future searches in all depth of the FKs Tree,
     * we set the flag of this album as DELETED
     * return 0 to denote that the FKs are not visible anymore
     */
    def amortizePath (pk: AlbPK): Int = {
        this.albsTable.setFlag(pk, 0)
        0
    }
    /*
     * HAS VISIBLE FKs VERSIONS
     * return - false if some FK is not visible anymore (the version of the FK in this Album does not match the version of the FK in the original referenced table)
     *          (check one FK at a time, so if the first is not visible for example, we don't need to check the others)
     *          true if all FKs are still visible
     * @Pre: the album with the given PK exists
     */
    private def hasVisibleFKsVersions(elem: Tuple[DWFlags, Alb]): Boolean = {
        if (this.artsTable.getVersion(elem.snd.artFK) != elem.fst.get_fk_version(0)) { // each idx in fk_versions has the version of the referenced element corresponding to the FK_System referenced tables, IN ORDER
            this.amortizePath(elem.snd.albPK)
            false
        }
        // else if ... check all other FKs if there are more
        else
            true
    }


    /*
     * GET VERSION
     * To be called by other FK_Systems which have Albums as FKs
     * return the version of the album with the given PK
     * @Pre: the album with the given PK exists
      */
    def getVersion (pk: AlbPK): Int = {
        val elem = this.albsTable.elements.get(pk)
        if (elem.fst.flag == 0) //DELETED
            0
        else if (this.hasVisibleFKsVersions(elem))
            elem.fst.version
        else
            this.amortizePath(elem.snd.albPK)
    }


    /*
     * REF INTEGRITY HOLDS - ELEMENT
     * return true if the referential integrity holds for the album with the given PK
     */
    def refIntegrityHolds_elem(pk : AlbPK): Boolean =
        this.hasVisibleFKsVersions(this.albsTable.elements.get(pk))


    /*
    * REF INTEGRITY HOLDS - TABLE
    * return true if the referential integrity holds for all elements in the table
    */
    def refIntegrityHolds_table(): Boolean =
        this.albsTable.elements.values().forall(
            (elem: Tuple[DWFlags, Alb]) => this.hasVisibleFKsVersions(elem) )


}



/*
 * OBJECT FOR REFERENTIAL INTEGRITY PROOFS
 */
object Alb_FK_System extends CvRDTProof1[Alb_FK_System] {

    // GENERIC REFERENTIAL INTEGRITY PROOF
	proof genericReferentialIntegrity[Time] {
        forall(s1: Alb_FK_System[Time], s2: Alb_FK_System[Time], pk: AlbPK) {
            ( s1.compatible(s2) &&
              s1.reachable() && s2.reachable() &&
              s1.refIntegrityHolds_elem(pk) && s2.refIntegrityHolds_elem(pk)
              ) =>: {
                s1.merge(s2).refIntegrityHolds_elem(pk)
              }
        }
    }

    // REFERENTIAL INTEGRITY PROOF FOR CONCURRENT DELETIONS
    proof refIntegrityHolds_For_Concurrent_Deletions[Time] {
        forall(s1: Alb_FK_System[Time], s2: Alb_FK_System[Time], artPK: ArtPK) {
            ( s1.reachable() && s2.reachable() &&
              s1.artsTable.delete(artPK)
            ) =>: {
                s1.merge(s2).refIntegrityHolds_table()
            }
        }
    }

}
