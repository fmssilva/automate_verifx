
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof
import antidote.crdts.registers.LWWRegister
import antidote.crdts.LamportClock



/**
 * Class representing the element(row):::  ALB
 *
 * given by the Antidote SQL command:
 *
 *		CREATE UPDATE-WINS TABLE ALB (
 *		TITLE VARCHAR PRIMARY KEY ,
 *		ART_NAME VARCHAR FOREIGN KEY UPDATE-WINS REFERENCES ART ( NAME ) ,
 *		ART_COUNTRY VARCHAR FOREIGN KEY UPDATE-WINS REFERENCES ART ( COUNTRY ) ,
 *		YEAR LWW INT CHECK ( YEAR >= 1900 AND YEAR <= 2022 ) ,
 *		PRICE LWW INT CHECK ( PRICE >= 0 AND PRICE <= 10000 ) ,
 *		)
 */
class Alb(
        title: String,  // PK
        pk_version: LWWRegister[Int], // PK_version
        art_name: String, art_country: String, //FK
        year: LWWRegister[Int], price: LWWRegister[Int] //other atrributes
        ) extends CvRDT[Alb] {


  /*
   * IMPLEMENTATION OF METHODS DECLARED IN CVRDT TRAIT
   */

	// merge this Alb with that Alb
	// only concurrently updatable attributes are merged as a CRDT
	// Returns the LUB of `this` and `that`
	def merge(that: Alb) =
	 	new Alb(this.title, this.pk_version.merge(that.pk_version), this.art_name, this.art_country, this.year.merge(that.year), this.price.merge(that.price))

	//compare this Alb with that Alb (only concurrently updatable attributes matter)
	def compare(that: Alb) =
    	this.pk_version.compare(that.pk_version) &&
		this.year.compare(that.year) &&
		this.price.compare(that.price)



  /*
   * OVERRIDE METHODS IMPLEMENTED IN CVRDT TRAIT
   */

	//this Alb is compatible with that Alb?
	override def compatible(that: Alb) =
		this.title == that.title &&
	    this.pk_version.compatible(that.pk_version) &&
		this.art_name == that.art_name &&
		this.art_country == that.art_country &&
		this.year.compatible(that.year) &&
		this.price.compatible(that.price)

	//Alb is reachable given the CHECK conditions of its attributes?
	override def reachable() = {
		 this.year.value >= 1900 && this.year.value <= 2022 &&
		 this.price.value >= 0 && this.price.value <= 10000
	}



  /*
   * IMPLEMENT METHODS FOR CONCURRENTLY UPDATABLE ATTRIBUTES,
   * to be used by the prover, useful in CmRDT - Operations
   */

	def updateYear(newYear: Int, stampYear: LamportClock) = {
		if( newYear >= 1900 && newYear <= 2022)
			new Alb(this.title, this.pk_version, this.art_name, this.art_country, this.year.assign(newYear, stampYear), this.price)
		else
			this
	}

	def updatePrice(newPrice: Int, stampPrice: LamportClock) = {
		if( newPrice >= 0 && newPrice <= 10000)
			new Alb(this.title, this.pk_version, this.art_name, this.art_country, this.year, this.price.assign(newPrice, stampPrice))
		else
			this
	}

}




/*
* Object to implement the proof functions for the updatable attributes
*/

object Alb extends CvRDTProof[Alb] {

	proof Alb_updateYear_works {
		forall(elem: Alb, year1: Int, year2: Int, c1: LamportClock, c2: LamportClock ) {
			( elem.reachable()  &&  c1.smaller(c2) &&
			  year1 >= 1900 && year1 <= 2022 && year2 >= 1900 && year2 <= 2022
			 ) =>: {
				 //simulate the update of the element in 2 replicas, creating elem 1 and 2, and then merging them in elem12
				 val elem1 = elem.updateYear(year1, c1)
				 val elem2 = elem.updateYear(year2, c2)
				 val elem12 = elem1.merge(elem2)
				 //check if the update in elem 1 and 2 kept the correct values
				 elem1.title == elem.title && elem2.title == elem.title &&
				 elem1.pk_version == elem.pk_version && elem2.pk_version == elem.pk_version &&
				 elem1.art_name == elem.art_name && elem2.art_name == elem.art_name &&
				 elem1.art_country == elem.art_country && elem2.art_country == elem.art_country &&
				 elem1.year.value == year1 && elem2.year.value == year2 &&
				 elem1.price == elem.price && elem2.price == elem.price &&
				 //check if the merged values are correct and according to the chosen update-policy
				 elem12.title == elem.title &&
				 elem12.art_name == elem.art_name &&
				 elem12.art_country == elem.art_country &&
				 elem12.year.value == year2 &&
				 elem12.pk_version == elem.pk_version &&
				 elem12.price == elem.price
			}
		}
	}

	proof Alb_updatePrice_works {
		forall(elem: Alb, price1: Int, price2: Int, c1: LamportClock, c2: LamportClock ) {
			( elem.reachable()  &&  c1.smaller(c2) &&
			  price1 >= 0 && price1 <= 10000 && price2 >= 0 && price2 <= 10000
			 ) =>: {
				 //simulate the update of the element in 2 replicas, creating elem 1 and 2, and then merging them in elem12
				 val elem1 = elem.updatePrice(price1, c1)
				 val elem2 = elem.updatePrice(price2, c2)
				 val elem12 = elem1.merge(elem2)
				 //check if the update in elem 1 and 2 kept the correct values
				 elem1.title == elem.title && elem2.title == elem.title &&
 				 elem1.pk_version == elem.pk_version && elem2.pk_version == elem.pk_version &&
				 elem1.art_name == elem.art_name && elem2.art_name == elem.art_name &&
				 elem1.art_country == elem.art_country && elem2.art_country == elem.art_country &&
				 elem1.year == elem.year && elem2.year == elem.year &&
				 elem1.price.value == price1 && elem2.price.value == price2 &&
				 //check if the merged values are correct and according to the chosen update-policy
				 elem12.title == elem.title &&
				 elem12.art_name == elem.art_name &&
				 elem12.art_country == elem.art_country &&
				 elem12.year == elem.year &&
				 elem12.price.value == price2
			}
		}
	}

}
