
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof
import antidote.crdts.registers.LWWRegister
import antidote.crdts.LamportClock
import generatedSysTables.arts.Art


class AlbPK(title: String) {

    def equals(that: AlbPK): Boolean =
        this.title == that.title

    def compatible(that: AlbPK): Boolean =
        this.equals(that)

}

class Alb(  albPK: AlbPK,   // PK
            artFK: ArtPK,   // FK
            year: LWWRegister[Int], price: LWWRegister[Int] //other atrributes
            ) extends CvRDT[Alb] {



	// return True if all the CHECK conditions are met
	override def reachable(): Boolean = {
		this.year.value >= 1900 && this.year.value <= 2022 &&
		this.price.value >= 0 && this.price.value <= 10000
	}

	// merge this Alb with that Alb
	// only concurrently updatable attributes are merged as a CRDT
	// Returns the LUB of `this` and `that`
	def merge(that: Alb): Alb =
	        new Alb(this.albPK,
	                this.artFK,                                                             // keep FK
                    this.year.merge(that.year), this.price.merge(that.price))               // merge other attributes


	// return True if 'this is compatible that'
	// have same attributes of the same types, well formed...
    override def compatible(that: Alb): Boolean =
        this.albPK.compatible(that.albPK) &&
        this.artFK.compatible(that.artFK) &&
		this.year.compatible(that.year) &&
		this.price.compatible(that.price)



    // compare this Alb with that Alb
    // only concurrently updatable attributes matter
    // return True if `this <= that`
    def compare(that: Alb): Boolean =
        false
//        this.year.compare(that.year) &&
//        this.price.compare(that.price)

    override def equals (that: Alb): Boolean =
        this.albPK.equals(that.albPK) &&
        this.artFK.equals(that.artFK) &&
        this.year.equals(that.year) &&
        this.price.equals(that.price)

}


object Alb extends CvRDTProof[Alb] { }
