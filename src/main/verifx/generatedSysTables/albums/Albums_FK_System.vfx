import antidote.crdts.lemmas.CvRDT
import antidote.crdts.LamportClock
import antidote.crdts.VersionVector
import antidote.crdts.lemmas.CvRDTProof1
import generatedSysTables.albums.AlbumsTable
import generatedSysTables.artists.ArtistsTable

class Albums_FK_System[Time](albums: AlbumsTable[Time], artists: ArtistsTable[Time]) 
			 extends CvRDT[Albums_FK_System[Time]] {

	//override default implementation of methods in CvRDT trait

	override def reachable(): Boolean =
		this.albums.reachable() && this.artists.reachable()

	override def compatible(that: Albums_FK_System[Time]): Boolean =
		this.albums.compatible(that.albums) && this.artists.compatible(that.artists)

	override def equals(that: Albums_FK_System[Time]) =
		this == that

	//implement declared methods in CvRDT trait

	def merge(that: Albums_FK_System[Time]) =
		new Albums_FK_System(this.albums.merge(that.albums), this.artists.merge(that.artists))

	def compare(that: Albums_FK_System[Time]) = //ignore
		true

	//methods to use in the Ref Integrity Proof

	def refIntegrityHolds(title: String) = {
		(this.albums.isVisible(title) 
		) =>: {
			val album = this.albums.get(title)
			this.artists.isVisible(album.fst.title)
		}
	}

	//other methods??

	def reachableWithAssociativityAssumptions(): Boolean = {
		this.albums.reachable() && this.artists.reachable() &&
			this.mergeValuesAssumptions()
	}

	private def mergeValuesAssumptions(): Boolean = {
		forall(v1: AlbumsTable[Time], v2: AlbumsTable[Time], v3: AlbumsTable[Time]) {
		  v1.merge(v2).merge(v3) == v1.merge(v2.merge(v3)) //merge is associative
		} &&
		forall(v1: ArtistsTable[Time], v2: ArtistsTable[Time], v3: ArtistsTable[Time]) {
		   v1.merge(v2).merge(v3) == v1.merge(v2.merge(v3)) //merge is associative
		}
	}}

	//OBJECT FOR OTHER PROOFS

object Albums_FK_System extends CvRDTProof1[Albums_FK_System] {

	proof genericReferentialIntegrity[Time] {
		forall(s1: Albums_FK_System[Time], s2: Albums_FK_System[Time], title: String) {
			( s1.reachable() && s2.reachable() && 
			  s1.compatible(s2) &&
			  s1.refIntegrityHolds(title) && s2.refIntegrityHolds(title) 
			) =>: {
				s1.merge(s2).refIntegrityHolds(title)
			}
		}
	}

	proof mergeIsAssociative[Time] {
		forall(s1: Albums_FK_System[Time], s2: Albums_FK_System[Time], s3: Albums_FK_System[Time]) {
			(s1.reachable() && s2.reachable() && s3.reachable() &&
			  s1.compatible(s2) && s1.compatible(s3) && s2.compatible(s3)
			) =>: {
				val aux = s1.merge(s2).merge(s3)
				aux.equals(s1.merge(s2.merge(s3)))
				aux.reachable()
				}
		}
	}}
