
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof
import antidote.crdts.registers.LWWRegister
import antidote.crdts.LamportClock

/**
 * Class representing the element(row):::  SONG 
 *
 * given by the Antidote SQL command:
 *
 *		CREATE UPDATE-WINS TABLE SONG (
 *		S_TITLE VARCHAR PRIMARY KEY ,
 *		ALB_TITLE VARCHAR FOREIGN KEY UPDATE-WINS REFERENCES ALB ( TITLE ) ,
 *		STYLE VARCHAR FOREIGN KEY UPDATE-WINS REFERENCES GENRE ( STYLE ) ,
 *		DURATION LWW INT CHECK ( DURATION >= 0 AND DURATION <= 1000 ) ,
 *		)
 */
class Song(s_title: String, alb_title: String, style: String, duration: LWWRegister[Int]) extends CvRDT[Song] {



  /*
   * IMPLEMENTATION OF METHODS DECLARED IN CVRDT TRAIT
   */

	//merge this Song with that Song
	def merge(that: Song) = 
		//args: s_title (PK); alb_title (FK); style (FK); duration (attrib)
		new Song(this.s_title, this.alb_title, this.style, this.duration.merge(that.duration))

	//compare this Song with that Song
	def compare(that: Song) = 
		this.duration.compare(that.duration)



  /*
   * OVERRIDE METHODS IMPLEMENTED IN CVRDT TRAIT
   */

	//this Song is compatible with that Song?
	override def compatible(that: Song) = 
		//args: s_title (PK); alb_title (FK); style (FK); duration (attrib)
		this.s_title == that.s_title &&
		this.alb_title == that.alb_title &&
		this.style == that.style &&
		this.duration.compatible(that.duration)

	//Song is reachable given the CHECK conditions of its attributes?
	override def reachable() = { 
		 this.duration.value >= 0 && this.duration.value <= 1000
	}



  /*
   * IMPLEMENT METHODS FOR CONCURRENTLY UPDATABLE ATTRIBUTES,
   * to be used by the prover, useful in CmRDT - Operations
   */

	def updateDuration(newDuration: Int, stampDuration: LamportClock) = { 
		if( newDuration >= 0 && newDuration <= 1000)
			new Song(this.s_title, this.alb_title, this.style, this.duration.assign(newDuration, stampDuration))
		else
			this
	}

}




/*
* Object to implement the proof functions for the updatable attributes
*/

object Song extends CvRDTProof[Song] {

	proof Song_updateDuration_works {
		forall(elem: Song, duration1: Int, duration2: Int, c1: LamportClock, c2: LamportClock ) {
			( elem.reachable()  &&  c1.smaller(c2) &&
			  duration1 >= 0 && duration1 <= 1000 && duration2 >= 0 && duration2 <= 1000
			 ) =>: {
				 //simulate the update of the element in 2 replicas, creating elem 1 and 2, and then merging them in elem12
				 val elem1 = elem.updateDuration(duration1, c1)
				 val elem2 = elem.updateDuration(duration2, c2)
				 val elem12 = elem1.merge(elem2)
				 //check if the update in elem 1 and 2 kept the correct values
				 elem1.s_title == elem.s_title && elem2.s_title == elem.s_title &&
				 elem1.alb_title == elem.alb_title && elem2.alb_title == elem.alb_title &&
				 elem1.style == elem.style && elem2.style == elem.style &&
				 elem1.duration.value == duration1 && elem2.duration.value == duration2 &&
				 //check if the merged values are correct and according to the chosen update-policy 
				 elem12.s_title == elem.s_title &&
				 elem12.alb_title == elem.alb_title &&
				 elem12.style == elem.style &&
				 elem12.duration.value == duration2
			}
		}
	}

}
