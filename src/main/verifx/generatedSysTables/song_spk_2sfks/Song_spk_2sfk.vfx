
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof
import antidote.crdts.registers.LWWRegister
import antidote.crdts.LamportClock



/**
 * Class representing the element(row):::  SONG_SPK_2SFK 
 *
 * given by the Antidote SQL command:
 *
 *		CREATE UPDATE-WINS TABLE SONG_SPK_2SFK (
 *		S_TITLE VARCHAR PRIMARY KEY ,
 *		GENR_STYLE VARCHAR FOREIGN KEY UPDATE-WINS REFERENCES GENRE_SPK ( STYLE ) ,
 *		ALB_TITLE VARCHAR FOREIGN KEY UPDATE-WINS REFERENCES ALB_SPK_1CFK ( TITLE ) ,
 *		DURATION LWW INT CHECK ( DURATION >= 0 AND DURATION <= 1000 ) ,
 *		)
 */
class Song_spk_2sfk(s_title: String, genr_style: String, alb_title: String, duration: LWWRegister[Int]) extends CvRDT[Song_spk_2sfk] {


  /*
   * IMPLEMENTATION OF METHODS DECLARED IN CVRDT TRAIT
   */

	//merge this Song_spk_2sfk with that Song_spk_2sfk (only concurrently updatable attributes are merged as a CRDT)
	def merge(that: Song_spk_2sfk) = 
		new Song_spk_2sfk(this.s_title, this.genr_style, this.alb_title, this.duration.merge(that.duration))

	//compare this Song_spk_2sfk with that Song_spk_2sfk (only concurrently updatable attributes matter)
	def compare(that: Song_spk_2sfk) = 
		this.duration.compare(that.duration)



  /*
   * OVERRIDE METHODS IMPLEMENTED IN CVRDT TRAIT
   */

	//this Song_spk_2sfk is compatible with that Song_spk_2sfk?
	override def compatible(that: Song_spk_2sfk) = 
		this.s_title == that.s_title && 
		this.genr_style == that.genr_style &&
		this.alb_title == that.alb_title &&
		this.duration.compatible(that.duration)

	//Song_spk_2sfk is reachable given the CHECK conditions of its attributes?
	override def reachable() = { 
		 this.duration.value >= 0 && this.duration.value <= 1000
	}



  /*
   * IMPLEMENT METHODS FOR CONCURRENTLY UPDATABLE ATTRIBUTES,
   * to be used by the prover, useful in CmRDT - Operations
   */

	def updateDuration(newDuration: Int, stampDuration: LamportClock) = { 
		if( newDuration >= 0 && newDuration <= 1000)
			new Song_spk_2sfk(this.s_title, this.genr_style, this.alb_title, this.duration.assign(newDuration, stampDuration))
		else
			this
	}

}




/*
* Object to implement the proof functions for the updatable attributes
*/

object Song_spk_2sfk extends CvRDTProof[Song_spk_2sfk] {

	proof Song_spk_2sfk_updateDuration_works {
		forall(elem: Song_spk_2sfk, duration1: Int, duration2: Int, c1: LamportClock, c2: LamportClock ) {
			( elem.reachable()  &&  c1.smaller(c2) &&
			  duration1 >= 0 && duration1 <= 1000 && duration2 >= 0 && duration2 <= 1000
			 ) =>: {
				 //simulate the update of the element in 2 replicas, creating elem 1 and 2, and then merging them in elem12
				 val elem1 = elem.updateDuration(duration1, c1)
				 val elem2 = elem.updateDuration(duration2, c2)
				 val elem12 = elem1.merge(elem2)
				 //check if the update in elem 1 and 2 kept the correct values
				 elem1.s_title == elem.s_title && elem2.s_title == elem.s_title &&
				 elem1.genr_style == elem.genr_style && elem2.genr_style == elem.genr_style &&
				 elem1.alb_title == elem.alb_title && elem2.alb_title == elem.alb_title &&
				 elem1.duration.value == duration1 && elem2.duration.value == duration2 &&
				 //check if the merged values are correct and according to the chosen update-policy 
				 elem12.s_title == elem.s_title &&
				 elem12.genr_style == elem.genr_style &&
				 elem12.alb_title == elem.alb_title &&
				 elem12.duration.value == duration2
			}
		}
	}

}
