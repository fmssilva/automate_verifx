
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.LamportClock
import antidote.crdts.VersionVector
import antidote.crdts.lemmas.CvRDTProof1
import generatedSysTables.song_view_cpk_1cfk_2sfks.Song_view_cpk_1cfk_2sfksTable
import generatedSysTables.art_cpks.Art_cpksTable
import generatedSysTables.song_spk_2sfks.Song_spk_2sfksTable
import generatedSysTables.alb_spk_1cfks.Alb_spk_1cfksTable
import generatedSysTables.genre_spks.Genre_spksTable
import generatedSysTables.art_cpks.Art_cpk

/*
 * class implementing the FK - Referential Integrity - Invariant
 */
class Song_view_cpk_1cfk_2sfk_FK_System[Time](
					song_view_cpk_1cfk_2sfksTable: Song_view_cpk_1cfk_2sfksTable[Time],
					art_cpksTable: Art_cpksTable[Time], 
					song_spk_2sfksTable: Song_spk_2sfksTable[Time], 
					alb_spk_1cfksTable: Alb_spk_1cfksTable[Time], 
					genre_spksTable: Genre_spksTable[Time] )
					extends CvRDT[Song_view_cpk_1cfk_2sfk_FK_System[Time]] {


  /*
   * OVERRIDE DEFAULT IMPLEMENTATION OF METHODS IN CvRDT TRAIT
   */ 

	//REACHABLE - check if this table and the referenced tables are reachable
	override def reachable(): Boolean =
				this.song_view_cpk_1cfk_2sfksTable.reachable() && 
				this.art_cpksTable.reachable() && 
				this.song_spk_2sfksTable.reachable() && 
				this.alb_spk_1cfksTable.reachable() && 
				this.genre_spksTable.reachable()


	//COMPATIBLE - check if this Song_view_cpk_1cfk_2sfk_FK_System is compatible with that song_view_cpk_1cfk_2sfksTable
	override def compatible(that: Song_view_cpk_1cfk_2sfk_FK_System[Time]): Boolean =
				this.song_view_cpk_1cfk_2sfksTable.compatible(that.song_view_cpk_1cfk_2sfksTable) &&
				this.art_cpksTable.compatible(that.art_cpksTable) &&
				this.song_spk_2sfksTable.compatible(that.song_spk_2sfksTable) &&
				this.alb_spk_1cfksTable.compatible(that.alb_spk_1cfksTable) &&
				this.genre_spksTable.compatible(that.genre_spksTable)


	//EQUALS - check if this Song_view_cpk_1cfk_2sfk_FK_System is equal to that Song_view_cpk_1cfk_2sfk_FK_System
	override def equals(that: Song_view_cpk_1cfk_2sfk_FK_System[Time]) =
				this == that


  /*
   * IMPLEMENT DECLARED METHODS IN CvRDT TRAIT
   */

	//MERGE this Song_view_cpk_1cfk_2sfk_FK_System with that Song_view_cpk_1cfk_2sfk_FK_System
	def merge(that: Song_view_cpk_1cfk_2sfk_FK_System[Time]) =
		new Song_view_cpk_1cfk_2sfk_FK_System(
				this.song_view_cpk_1cfk_2sfksTable.merge(that.song_view_cpk_1cfk_2sfksTable), 
				this.art_cpksTable.merge(that.art_cpksTable),
				this.song_spk_2sfksTable.merge(that.song_spk_2sfksTable),
				this.alb_spk_1cfksTable.merge(that.alb_spk_1cfksTable),
				this.genre_spksTable.merge(that.genre_spksTable) )

	//COMPARE this Song_view_cpk_1cfk_2sfk_FK_System with that Song_view_cpk_1cfk_2sfk_FK_System
	//ignore
	def compare(that: Song_view_cpk_1cfk_2sfk_FK_System[Time]) = 
				true



  /*
   * EXTRA METHODS FOR PROOFS
   */

	//REFERENTIAL INTEGRITY
	//Checks if for every elem of Song_view_cpk_1cfk_2sfksTable, there is the corresponding element in the referenced tables
	def refIntegrityHolds(pk: Song_view_cpk_1cfk_2sfk_PKs) = {
		(this.song_view_cpk_1cfk_2sfksTable.isVisible(pk) 
		 ) =>: {
				val song_view_cpk_1cfk_2sfk = this.song_view_cpk_1cfk_2sfksTable.get(pk).fst
				this.art_cpksTable.isVisible( new Art_cpk_PKs(song_view_cpk_1cfk_2sfk.art_name, song_view_cpk_1cfk_2sfk.art_country))
				this.song_spk_2sfksTable.isVisible(song_view_cpk_1cfk_2sfk.s_title)
				this.alb_spk_1cfksTable.isVisible(song_view_cpk_1cfk_2sfk.alb_title)
				this.genre_spksTable.isVisible(song_view_cpk_1cfk_2sfk.genr_style)
				}
	}

	// REACHABLE WITH ASSUMPTIONS - ASSOCIATIVITY
	def reachableWithAssociativityAssumptions(): Boolean = {
				this.song_view_cpk_1cfk_2sfksTable.reachable() && 
				this.art_cpksTable.reachable() &&
				this.song_spk_2sfksTable.reachable() &&
				this.alb_spk_1cfksTable.reachable() &&
				this.genre_spksTable.reachable() && 
				this.mergeValuesAssumptions()
	}
		//HELPER METHOD - ASSUMPTIONS FOR MERGE ASSOCIATIVITY - for the tables of this Song_view_cpk_1cfk_2sfk_FK_System
		private def mergeValuesAssumptions(): Boolean = {
			forall(v1: Song_view_cpk_1cfk_2sfksTable[Time], v2: Song_view_cpk_1cfk_2sfksTable[Time], v3: Song_view_cpk_1cfk_2sfksTable[Time])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  } &&
			forall(v1: Art_cpksTable[Time], v2: Art_cpksTable[Time], v3: Art_cpksTable[Time])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  } &&
			forall(v1: Song_spk_2sfksTable[Time], v2: Song_spk_2sfksTable[Time], v3: Song_spk_2sfksTable[Time])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  } &&
			forall(v1: Alb_spk_1cfksTable[Time], v2: Alb_spk_1cfksTable[Time], v3: Alb_spk_1cfksTable[Time])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  } &&
			forall(v1: Genre_spksTable[Time], v2: Genre_spksTable[Time], v3: Genre_spksTable[Time])
				  { v1.merge(v2).merge(v3) == v1.merge( v2.merge(v3) )
				  }
		}

}



/*
 * OBJECT FOR EXTRA PROOFS
 */
object Song_view_cpk_1cfk_2sfk_FK_System extends CvRDTProof1[Song_view_cpk_1cfk_2sfk_FK_System] {

	//REFERENTIAL INTEGRITY
	proof genericReferentialIntegrity[Time] {
		forall(s1: Song_view_cpk_1cfk_2sfk_FK_System[Time], s2: Song_view_cpk_1cfk_2sfk_FK_System[Time], pk: Song_view_cpk_1cfk_2sfk_PKs) {
			( s1.reachable() && s2.reachable() && 
			  s1.compatible(s2) &&
			  s1.refIntegrityHolds(pk) && s2.refIntegrityHolds(pk) 
			) =>: {
				s1.merge(s2).refIntegrityHolds(pk)
			}
		}
	}

	//MERGE ASSOCIATIVE
	proof mergeIsAssociative[Time] {
		forall(s1: Song_view_cpk_1cfk_2sfk_FK_System[Time], s2: Song_view_cpk_1cfk_2sfk_FK_System[Time], s3: Song_view_cpk_1cfk_2sfk_FK_System[Time]) {
			(s1.reachable() && s2.reachable() && s3.reachable() &&
			  s1.compatible(s2) && s1.compatible(s3) && s2.compatible(s3)
			) =>: {
				val aux = s1.merge(s2).merge(s3)
				aux.equals(s1.merge( s2.merge(s3) ))
				aux.reachable()
				}
		}
	}}
