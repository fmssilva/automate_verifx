
import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof
import antidote.crdts.registers.LWWRegister
import antidote.crdts.LamportClock


class ArtPK(name: Int) { //TODO: meti name Int pra meter restrição de possibilidades limitadas pra ver se ajuda no Z3

    // return True if all the CHECK conditions are met
    def reachable(): Boolean =
        this.name >= 0 && this.name <= 100

    def equals(that: ArtPK): Boolean =
        this.name == that.name

}



/**
 * Class representing the element(row):::  ART 
 *
 * given by the Antidote SQL command:
 *
 *		CREATE UPDATE-WINS TABLE ART (
 *		NAME VARCHAR PRIMARY KEY
 *		COUNTRY VARCHAR PRIMARY KEY ,
 *		AGE LWW INT CHECK ( AGE >= 0 AND AGE <= 100 ) ,
 *		RANKING LWW INT CHECK ( RANKING >= 0 AND RANKING <= 100 ) ,
 *		)
 */
class Art(artPK: ArtPK, age: LWWRegister[Int], ranking: LWWRegister[Int]) extends CvRDT[Art] {

	override def reachable() = {
	    this.artPK.reachable() &&
		this.age.value >= 0 && this.age.value <= 100 &&
		this.ranking.value >= 0 && this.ranking.value <= 100
	}

    override def equals (that: Art): Boolean = {
        this.artPK.equals(that.artPK) &&
        this.age.equals(that.age) &&
        this.ranking.equals(that.ranking)
    }

	def compare(that: Art) =
        false

	override def compatible(that: Art) = {
		this.artPK.equals(that.artPK) &&
		this.age.compatible(that.age) &&
		this.ranking.compatible(that.ranking)
    }

	def merge(that: Art) = {
		new Art(this.artPK, this.age.merge(that.age), this.ranking.merge(that.ranking))
    }

}

object Art extends CvRDTProof[Art] { }
