import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof
import antidote.crdts.registers.LWWRegister
import antidote.crdts.LamportClock

/**
 * Class representing the element:   ART 
 * given by the Antidote SQL command:
 *		CREATE UPDATE-WINS TABLE ART (
 *		ART_NAME VARCHAR PRIMARY KEY
 *		COUNTRY LWW VARCHAR
 *		)
 */
class Art(art_name: String, country: LWWRegister[String]) extends CvRDT[Art] {


	//Implementation of methods DECLARED in CvRDT trait

	def merge(that: Art) = 
		new Art(this.art_name, this.country.merge(that.country))

	def compare(that: Art) = 
		this.country.compare(that.country)


	//Override Methods IMPLEMENTED in CvRDT trait

	override def compatible(that: Art) = 
		this.art_name == that.art_name &&
		this.country.compatible(that.country)


	//Implement methods for concurrently updatable attributes to be used by the tester,
	//useful in CmRDT - Operations

	def updateCountry(newCountry: String, stampCountry: LamportClock) = { 
			new Art(this.art_name, this.country.assign(newCountry, stampCountry))
	}

}




/*
* Object to implement the proof functions for the updatable attributes
*/

object Art extends CvRDTProof[Art] {

	proof Art_updateCountry_works {
		forall(elem: Art, country1: String, country2: String, c1: LamportClock, c2: LamportClock ) {
			( elem.reachable()  &&  c1.smaller(c2)
			 ) =>: {
				 //simulate the update of the element in 2 replicas, creating elem 1 and 2, and then merging them in elem12
				 val elem1 = elem.updateCountry(country1, c1)
				 val elem2 = elem.updateCountry(country2, c2)
				 val elem12 = elem1.merge(elem2)
				 //check if the update in elem 1 and 2 kept the correct values
				 elem1.art_name == elem.art_name && elem2.art_name == elem.art_name &&
				 elem1.country.value == country1 && elem2.country.value == country2 &&
				 //check if the merged values are correct and according to the chosen update-policy 
				 elem12.art_name == elem.art_name &&
				 elem12.country.value == country2
			}
		}
	}

}
