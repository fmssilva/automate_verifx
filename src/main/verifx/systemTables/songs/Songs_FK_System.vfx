import antidote.crdts.lemmas.CvRDT
import antidote.crdts.LamportClock
import antidote.crdts.VersionVector
import antidote.crdts.lemmas.CvRDTProof1
import systemTables.songs.SongsTable
import systemTables.albums.AlbumsTable

class Songs_FK_System[Time](songs: SongsTable[Time], albums: AlbumsTable[Time]) 
			 extends CvRDT[Songs_FK_System[Time]] {

	//override default implementation of methods in CvRDT trait

	override def reachable(): Boolean =
		this.songs.reachable() && this.albums.reachable()

	override def compatible(that: Songs_FK_System[Time]): Boolean =
		this.songs.compatible(that.songs) && this.albums.compatible(that.albums)

	override def equals(that: Songs_FK_System[Time]) =
		this == that

	//implement declared methods in CvRDT trait

	def merge(that: Songs_FK_System[Time]) =
		new Songs_FK_System(this.songs.merge(that.songs), this.albums.merge(that.albums))

	def compare(that: Songs_FK_System[Time]) = //ignore
		true

	//methods to use in the Ref Integrity Proof

	def refIntegrityHolds(title: String) = {
		(this.songs.isVisible(title) 
		) =>: {
			val song = this.songs.get(title)
			this.albums.isVisible(song.fst.title)
		}
	}

	//other methods??

	def reachableWithAssociativityAssumptions(): Boolean = {
		this.songs.reachable() && this.albums.reachable() &&
			this.mergeValuesAssumptions()
	}

	private def mergeValuesAssumptions(): Boolean = {
		forall(v1: SongsTable[Time], v2: SongsTable[Time], v3: SongsTable[Time]) {
		  v1.merge(v2).merge(v3) == v1.merge(v2.merge(v3)) //merge is associative
		} &&
		forall(v1: AlbumsTable[Time], v2: AlbumsTable[Time], v3: AlbumsTable[Time]) {
		   v1.merge(v2).merge(v3) == v1.merge(v2.merge(v3)) //merge is associative
		}
	}}

	//OBJECT FOR OTHER PROOFS

object Songs_FK_System extends CvRDTProof1[Songs_FK_System] {

	proof genericReferentialIntegrity[Time] {
		forall(s1: Songs_FK_System[Time], s2: Songs_FK_System[Time], title: String) {
			( s1.reachable() && s2.reachable() && 
			  s1.compatible(s2) &&
			  s1.refIntegrityHolds(title) && s2.refIntegrityHolds(title) 
			) =>: {
				s1.merge(s2).refIntegrityHolds(title)
			}
		}
	}

	proof mergeIsAssociative[Time] {
		forall(s1: Songs_FK_System[Time], s2: Songs_FK_System[Time], s3: Songs_FK_System[Time]) {
			(s1.reachable() && s2.reachable() && s3.reachable() &&
			  s1.compatible(s2) && s1.compatible(s3) && s2.compatible(s3)
			) =>: {
				val aux = s1.merge(s2).merge(s3)
				aux.equals(s1.merge(s2.merge(s3)))
				aux.reachable()
				}
		}
	}}
