import antidote.crdts.lemmas.CvRDT
import antidote.crdts.lemmas.CvRDTProof
import antidote.crdts.registers.LWWRegister
import antidote.crdts.LamportClock

/**
 * Class representing the element:   ALBUM 
 * given by the Antidote SQL command:
 *		CREATE UPDATE-WINS TABLE ALBUM (
 *		TITLE VARCHAR PRIMARY KEY ,
 *		ART_ARTIST VARCHAR FOREIGN KEY UPDATE-WINS REFERENCES ARTIST ( NAME ) ,
 *		ART_COUNTRY VARCHAR FOREIGN KEY UPDATE-WINS REFERENCES ARTIST ( COUNTRY ) ,
 *		YEAR LWW INT CHECK ( YEAR >= 1900 AND YEAR <= 2022 ) ,
 *		PRICE LWW INT CHECK ( PRICE >= 0 AND PRICE <= 10000 ) ,
 *		)
 */
class Album(title: String, art_artist: String, art_country: String, year: LWWRegister[Int], price: LWWRegister[Int]) extends CvRDT[Album] {


	//Implementation of methods DECLARED in CvRDT trait

	def merge(that: Album) = 
		new Album(this.title, this.art_artist, this.art_country, this.year.merge(that.year), this.price.merge(that.price))

	def compare(that: Album) = 
		this.year.compare(that.year) &&
		this.price.compare(that.price)


	//Override Methods IMPLEMENTED in CvRDT trait

	override def reachable() = { 
		 this.year.value >= 1900 && this.year.value <= 2022 && 
		 this.price.value >= 0 && this.price.value <= 10000
	}

	override def compatible(that: Album) = 
		this.title == that.title &&
		this.art_artist == that.art_artist &&
		this.art_country == that.art_country &&
		this.year.compatible(that.year) &&
		this.price.compatible(that.price)


	//Implement methods for concurrently updatable attributes to be used by the prover,
	//useful in CmRDT - Operations

	def updateYear(newYear: Int, stampYear: LamportClock) = { 
		if( newYear >= 1900 && newYear <= 2022)
			new Album(this.title, this.art_artist, this.art_country, this.year.assign(newYear, stampYear), this.price)
		else
			this
	}

	def updatePrice(newPrice: Int, stampPrice: LamportClock) = { 
		if( newPrice >= 0 && newPrice <= 10000)
			new Album(this.title, this.art_artist, this.art_country, this.year, this.price.assign(newPrice, stampPrice))
		else
			this
	}

}




/*
* Object to implement the proof functions for the updatable attributes
*/

object Album extends CvRDTProof[Album] {

	proof Album_updateYear_works {
		forall(elem: Album, year1: Int, year2: Int, c1: LamportClock, c2: LamportClock ) {
			( elem.reachable()  &&  c1.smaller(c2) &&
			  year1 >= 1900 && year1 <= 2022 && year2 >= 1900 && year2 <= 2022
			 ) =>: {
				 //simulate the update of the element in 2 replicas, creating elem 1 and 2, and then merging them in elem12
				 val elem1 = elem.updateYear(year1, c1)
				 val elem2 = elem.updateYear(year2, c2)
				 val elem12 = elem1.merge(elem2)
				 //check if the update in elem 1 and 2 kept the correct values
				 elem1.title == elem.title && elem2.title == elem.title &&
				 elem1.art_artist == elem.art_artist && elem2.art_artist == elem.art_artist &&
				 elem1.art_country == elem.art_country && elem2.art_country == elem.art_country &&
				 elem1.year.value == year1 && elem2.year.value == year2 &&
				 elem1.price == elem.price && elem2.price == elem.price &&
				 //check if the merged values are correct and according to the chosen update-policy 
				 elem12.title == elem.title &&
				 elem12.art_artist == elem.art_artist &&
				 elem12.art_country == elem.art_country &&
				 elem12.year.value == year2 &&
				 elem12.price == elem.price
			}
		}
	}

	proof Album_updatePrice_works {
		forall(elem: Album, price1: Int, price2: Int, c1: LamportClock, c2: LamportClock ) {
			( elem.reachable()  &&  c1.smaller(c2) &&
			  price1 >= 0 && price1 <= 10000 && price2 >= 0 && price2 <= 10000
			 ) =>: {
				 //simulate the update of the element in 2 replicas, creating elem 1 and 2, and then merging them in elem12
				 val elem1 = elem.updatePrice(price1, c1)
				 val elem2 = elem.updatePrice(price2, c2)
				 val elem12 = elem1.merge(elem2)
				 //check if the update in elem 1 and 2 kept the correct values
				 elem1.title == elem.title && elem2.title == elem.title &&
				 elem1.art_artist == elem.art_artist && elem2.art_artist == elem.art_artist &&
				 elem1.art_country == elem.art_country && elem2.art_country == elem.art_country &&
				 elem1.year == elem.year && elem2.year == elem.year &&
				 elem1.price.value == price1 && elem2.price.value == price2 &&
				 //check if the merged values are correct and according to the chosen update-policy 
				 elem12.title == elem.title &&
				 elem12.art_artist == elem.art_artist &&
				 elem12.art_country == elem.art_country &&
				 elem12.year == elem.year &&
				 elem12.price.value == price2
			}
		}
	}

}
